# Ніколя переконаний, що Софія дзвонить додому надто багато і має великі рахунки за дзвінки. Він зібрав рахунки дзвінків Софії 
# за останні кілька днів і хоче порахувати, скільки витратила Софія на розмови.

# Рахунок представлений у вигляді масиву, що містить інформацію про дзвінки. Допоможіть Ніколя підрахувати вартість кожного 
# дзвінка Софії. Кожен дзвінок представлений як рядок, що містить дату, час та тривалість розмови в секундах у наступному форматі:
# "РРРР-ММ-ДД чч:мм:сс тривалість"
# Де дата та час - це дата та час початку дзвінка.
# У компанії "Space-Time Communications" діють такі тарифи:

# Перші 100 (сто) хвилин на день оплачуються за тарифом 1 монета за хвилину;
# Після 100 хвилин розмови на день, кожна хвилина коштує 2 монети;
# Тривалість всіх дзвінків заокруглюється до хвилин. Наприклад, 59 сек ≈ 1 хв, 61 сек ≈ 2 хв;
# Дзвінки вважаються за той день, коли вони почалися. Наприклад, якщо дзвінок розпочався 2014-01-01 23:59:59, то він 
# відноситься до 2014-01-01;
# Наприклад:

# 2014-01-01 01:12:13 181
# 2014-01-02 20:11:10 600
# 2014-01-03 01:12:13 6009
# 2014-01-03 12:13:55 200
# Перший день - 181с≈4м - 4 монети;
# Другий день - 600с = 10м - 10 монет;
# Третій день - 6009с ≈ 101м + 200с ≈ 4м - 100 + 5 * 2 = 110 монет;
# Усього - 124 монети.
# Вхідні дані: Інформація про дзвінки у вигляді кортежу (tuple) рядків (strings).

# Вихідні дані: Загальна сума дзвінків як цілого числа(integer).

# Наприклад:

# 1
# total_cost(("2014-01-01 01:12:13 181",
# 2 
# "2014-01-02 20:11:10 600",
# 3 
# "2014-01-03 01:12:13 6009",
# 4 
# "2014-01-03 12:13:55 200")) == 124
# Як це використовувати: Це завдання навчить працювати з різними типами дати. Іноді повна дата не потрібна і потрібно 
# оперувати лише з необхідними фрагментами дати.

# Передумови: 0 < len(calls) ≤ 30
# 0 < call_duration ≤ 7200
# Рахунок відсортовано за датою.
from math import ceil

def total_cost(calls_log:tuple) -> int:
    coast = 0
    dates = {}
    
    for call_log in calls_log :
        date_log, _, seconsd_log = call_log.split(" ")
        if (date_log in dates):
            dates[date_log] += ceil(int(seconsd_log) / 60)
        else:
            dates[date_log] = ceil(int(seconsd_log) / 60)

    for minutes in dates.values():
        if minutes <= 100:
            coast += minutes
        else:
            coast += 100 + (minutes - 100) * 2
    
    return coast

if __name__ == "__main__": 
    assert total_cost(("2014-01-01 01:12:13 181",
    "2014-01-02 20:11:10 600",
    "2014-01-03 01:12:13 6009",
    "2014-01-03 12:13:55 200")) == 124
    
print(total_cost(("2014-01-01 01:12:13 181",
    "2014-01-02 20:11:10 600",
    "2014-01-03 01:12:13 6009",
    "2014-01-03 12:13:55 200")))